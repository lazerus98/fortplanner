<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quickfort Grid Editor</title>
  <style>
    :root { --bg:#0f0f12; --panel:#17171c; --muted:#2a2a32; --fg:#e6e6e9; --fg2:#b8b8c2; --accent:#22c55e; --accent2:#7ee081; --warn:#ffbd5c; --bad:#ff6b6b; --grid:#2a2a32; --cell:#1f1f26; --cell-hover:#23232b; --cell-active:#333344; --tab-bg:#14141a; --zoom:1; --cell-size:24px; --cell-font:12px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif; background: var(--bg); color: var(--fg); }
    header { padding: 12px 16px; border-bottom: 1px solid var(--muted); background: var(--panel); display: flex; align-items: center; gap: 12px; }
    header h1 { font-size: 18px; margin: 0; font-weight: 600; }
    header .spacer { flex: 1; }
    header .controls { display: flex; gap: 8px; align-items: center; position: relative; }
    header input[type=number] { width: 84px; padding: 6px 8px; background: var(--cell); border: 1px solid var(--muted); color: var(--fg); border-radius: 6px; }
    /* Hide native number spinners */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; appearance: textfield; }
    header button { padding: 8px 10px; background: var(--accent); color: #021018; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; }
    header button.secondary { background: var(--muted); color: var(--fg2); }
    /* Visual toggle for header/status buttons in active mode */
    button.active { outline: 2px solid var(--accent); background: #13232d; color: var(--accent2); }
    main { display: grid; grid-template-columns: 280px 1fr; gap: 0; height: calc(100% - 54px); }
    aside { border-right: 1px solid var(--muted); background: var(--panel); overflow: auto; }
    .tools { padding: 12px; }
    .section { margin-bottom: 16px; }
    .section h3 { margin: 10px 0 8px; font-size: 13px; font-weight: 700; color: var(--fg2); text-transform: uppercase; letter-spacing: 0.06em; }
    .tool-grid { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 6px; }
    .tool { background: var(--cell); border: 1px solid var(--muted); padding: 8px; border-radius: 8px; cursor: pointer; font-size: 13px; text-align: center; color: var(--fg); }
    .tool small { display: block; color: var(--fg2); margin-top: 2px; font-size: 11px; }
    .tool.active { outline: 2px solid var(--accent); background: #13232d; }
    .tool.custom { grid-column: 1 / -1; display: grid; grid-template-columns: 1fr auto; gap: 6px; align-items: center; }
    .tool.custom input { padding: 8px; background: var(--cell); border: 1px solid var(--muted); color: var(--fg); border-radius: 8px; }
    .tool.custom button { background: var(--accent2); color: #07200d; border: none; padding: 8px 10px; border-radius: 8px; cursor: pointer; font-weight: 700; }
    .tool small.token-pill { display: inline-block; margin-top: 4px; padding: 2px 6px; border-radius: 999px; background: var(--muted); color: var(--fg2); }
    .tabs { display: flex; background: var(--tab-bg); border-bottom: 1px solid var(--muted); }
    .tabs button { flex: 0 0 auto; background: transparent; border: none; padding: 10px 14px; color: var(--fg2); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent; }
    .tabs button.active { color: var(--fg); border-bottom: 2px solid var(--accent); }
    .workspace { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    .gridwrap { overflow: auto; background: #0e0e13; padding: 12px; display: flex; flex-wrap: wrap; align-items: flex-start; gap: 16px; }
    .grid-container { position: relative; display: inline-block; }
    table.grid { border-collapse: collapse; background: var(--grid); table-layout: fixed; }
    table.grid td { width: calc(var(--cell-size) * var(--zoom)); height: calc(var(--cell-size) * var(--zoom)); line-height: calc(var(--cell-size) * var(--zoom)); text-align: center; vertical-align: middle; white-space: nowrap; overflow: hidden; background: var(--cell); color: var(--fg); border: 1px solid #1a1a21; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: calc(var(--cell-font) * var(--zoom)); user-select: none; position: relative; }
    /* Slightly smaller text for property-heavy tokens (display-only) */
    table.grid td.mini-token { font-size: calc(var(--cell-font) * var(--zoom) * 0.85) !important; }
    table.grid td:hover { background: var(--cell-hover); }
    table.grid td.active { background: var(--cell-active); }
    /* Persistent selection overlay */
    table.grid td.selected::after { content: ""; position: absolute; inset: 0; box-sizing: border-box;
      border: 2px solid #22c55e; /* accent */
      background: rgba(34,197,94,0.10);
      pointer-events: none; z-index: 3; }
    /* Mode cursors */
    .grid-container.select-mode table.grid td { cursor: crosshair; }
    .grid-container.paste-mode table.grid td { cursor: copy; }
    .statusbar { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-top: 1px solid var(--muted); background: var(--panel); color: var(--fg2); font-size: 12px; }
    .statusbar .actions { display: flex; gap: 8px; }
    .statusbar .actions button { padding: 6px 10px; border-radius: 6px; border: 1px solid var(--muted); background: var(--cell); color: var(--fg); cursor: pointer; }
    .statusbar .actions button.primary { background: var(--accent); color: #06121a; border: none; font-weight: 700; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid var(--muted); border-bottom-width: 2px; border-radius: 6px; background: var(--cell); color: var(--fg2); }
    .note { color: var(--fg2); font-size: 12px; }
    /* Preview styling */
    .preview { opacity: 0.55; pointer-events: none; filter: saturate(85%); }
    .preview table.grid td { /* static 80% of main grid size */
      width: calc(var(--cell-size) * var(--zoom) * 0.8);
      height: calc(var(--cell-size) * var(--zoom) * 0.8);
      line-height: calc(var(--cell-size) * var(--zoom) * 0.8);
      font-size: calc(var(--cell-font) * var(--zoom) * 0.8);
      background: var(--cell);
    }
    /* South (below) preview should take full row width */
    .preview.south { flex: 1 0 100%; width: 100%; display: flex; }
    /* Dig overlay: subtle crosshatch fill + dashed green border */
    .dig-overlay { position: absolute; inset: 0; box-sizing: border-box; border: 1px dashed #22c55e; background-image:
        repeating-linear-gradient(45deg, rgba(34,197,94,0.15) 0 8px, transparent 8px 16px),
        repeating-linear-gradient(-45deg, rgba(34,197,94,0.10) 0 8px, transparent 8px 16px);
      pointer-events: none; z-index: 1; }
    /* Mirror axes overlay */
    .axes-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 5; }
    .axis-line { position: absolute; background: var(--accent); opacity: 0.7; }
    .axis-line.v { width: 2px; top: 0; bottom: 0; }
    .axis-line.h { height: 2px; left: 0; right: 0; }
    .axis-handle { position: absolute; pointer-events: auto; }
    .axis-handle.v { width: 14px; top: 0; bottom: 0; cursor: col-resize; transform: translateX(-50%); }
    .axis-handle.h { height: 14px; left: 0; right: 0; cursor: row-resize; transform: translateY(-50%); }
    .axis-handle .grip { position: absolute; background: var(--accent); opacity: 0.85; }
    .axis-handle.v .grip { width: 2px; top: 0; bottom: 0; left: 50%; transform: translateX(-50%); }
    .axis-handle.h .grip { height: 2px; left: 0; right: 0; top: 50%; transform: translateY(-50%); }
    /* Shape preview overlay: distinct purple tone above dig overlay */
    table.grid td.shape-preview::after { content: ""; position: absolute; inset: 0; box-sizing: border-box;
      border: 2px dashed #7c3aed; background-image:
        repeating-linear-gradient(45deg, rgba(124,58,237,0.20) 0 6px, transparent 6px 12px);
      background-color: rgba(124,58,237,0.12); pointer-events: none; z-index: 2; }
    .hidden { display: none; }
    .hint { color: var(--warn); }
    .row { display: flex; gap: 8px; align-items: center; }
    .row input[type=text] { flex: 1; padding: 8px; background: var(--cell); border: 1px solid var(--muted); color: var(--fg); border-radius: 8px; }
    /* Paste hover preview overlay using a real element to render token text */
    table.grid td.paste-preview { position: relative; }
    table.grid td .paste-ghost { position: absolute; inset: 0; box-sizing: border-box; pointer-events: none; z-index: 4;
      display: flex; align-items: center; justify-content: center; padding: 0 2px; border-radius: 0; font-weight: 600; opacity: 0.85; }
    /* Help popover */
    .popover { position: absolute; right: 0; top: calc(100% + 8px); background: var(--panel); color: var(--fg2); border: 1px solid var(--muted); border-radius: 8px; padding: 8px 10px; font-size: 12px; width: max-content; max-width: 260px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); z-index: 10; }
    .popover strong { color: var(--fg); }
    .statusbar .actions .sep { display: inline-block; width: 1px; height: 24px; background: var(--muted); margin: 0 10px; vertical-align: middle; }
  </style>
</head>
<body>
  <header>
    <h1>Quickfort Grid Editor</h1>
    <div class="spacer"></div>
    <div class="controls">
      <label>Columns <input id="cols" type="number" min="1" max="300" value="30" /></label>
      <button id="cols-dec" class="secondary" title="Decrease columns">-</button>
      <button id="cols-inc" title="Increase columns">+</button>
      <label>Rows <input id="rows" type="number" min="1" max="300" value="20" /></label>
      <button id="rows-dec" class="secondary" title="Decrease rows">-</button>
      <button id="rows-inc" title="Increase rows">+</button>
      <div class="row" style="align-items:center; gap:6px;">
        <span id="zoom-label" class="note" style="min-width:56px; display:inline-block; text-align:center;">100%</span>
        <button id="zoom-out" class="secondary" title="Zoom out (Ctrl+-)">-</button>
        <button id="zoom-in" title="Zoom in (Ctrl+=)">+</button>
      </div>
      <div class="row" style="align-items:center; gap:6px; margin-left:6px;">
        <span id="z-label" class="note" style="min-width:56px; display:inline-block; text-align:center;">Z1/1</span>
        <button id="z-down" class="secondary" title="Down one z-level">Z-</button>
        <button id="z-up" title="Up one z-level">Z+</button>
        <button id="z-add" class="secondary" title="Add new z-level">Add Z</button>
        <button id="z-del" class="secondary" title="Delete current z-level">Del Z</button>
      </div>
      <label style="margin-left:8px;"><input id="preview-toggle" type="checkbox" checked /> Preview</label>
      <button id="cleargrid" class="secondary">Clear Current Grid</button>
      <button id="help-btn" class="secondary" title="Usage help">?</button>
      <div id="help-pop" class="popover hidden">
        Left-click paint, right-click erase, drag to paint.
      </div>
    </div>
  </header>
  <main>
    <aside>
      <div class="tools">
        <div class="section" id="shape-tools">
          <h3>Shape Tools</h3>
          <div class="row" style="gap:6px; align-items:center; flex-wrap:wrap;">
            <label>Shape
              <select id="shape-select" style="margin-left:6px; padding:4px 6px; background: var(--cell); border:1px solid var(--muted); color: var(--fg); border-radius:6px;">
                <option value="free">Freehand</option>
                <option value="rect">Rect</option>
                <option value="line">Line</option>
                <option value="circle">Circle</option>
                <option value="fill">Fill</option>
              </select>
            </label>
            <label id="shape-outline-wrap"><input id="shape-outline" type="checkbox" /> Hollow</label>
          </div>
          <div class="row" style="gap:6px; align-items:center; flex-wrap:wrap; margin-top:6px;">
            <label>Brush <input id="brush-size" type="number" min="1" max="25" value="1" /></label>
            <button id="brush-dec" class="secondary" title="Decrease brush">-</button>
            <button id="brush-inc" title="Increase brush">+</button>
          </div>
        </div>
        <div class="section" id="mirror-tools" style="margin-top:6px;">
          <h3>Mirror Axes</h3>
          <div class="row" style="gap:12px; align-items:center; flex-wrap:wrap;">
            <label title="Mirror across vertical axis"><input id="mirror-v-toggle" type="checkbox" /> Mirror V</label>
            <label title="Mirror across horizontal axis"><input id="mirror-h-toggle" type="checkbox" /> Mirror H</label>
          </div>
        </div>


        <div class="section" data-tools="dig">
          <h3>Dig Tools</h3>
          <div class="row" style="margin:6px 0 10px; gap:12px; align-items:center;">
            <label><input type="checkbox" id="dig-mb"> Blueprint</label>
            <label><input type="checkbox" id="dig-mw"> Warm</label>
            <label><input type="checkbox" id="dig-md"> Damp</label>
            <label>Priority
              <select id="dig-priority" style="margin-left:6px; padding:4px 6px; background: var(--cell); border:1px solid var(--muted); color: var(--fg); border-radius:6px;">
                <option value="">none</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
              </select>
            </label>
          </div>
          <div class="section" style="margin:0 0 8px;">
            <div class="tool-grid" id="dig-basic"></div>
          </div>
          <div class="section" style="margin:0 0 8px;">
            <h3>Item/Traffic</h3>
            <div class="tool-grid" id="dig-flags"></div>
          </div>
          <div class="section" style="margin:0 0 8px;">
            <h3>Tracks (carved)</h3>
            <div class="tool-grid" id="dig-tracks"></div>
          </div>
          <div class="tool custom" style="margin-top:8px;">
            <input type="text" placeholder="custom dig token (e.g., mdh5(10x10) or just 3)" />
            <button data-apply-custom>Use</button>
          </div>
        </div>

        <div class="section" data-tools="build">
          <h3>Build Tools</h3>
          <div class="row" style="margin-bottom:8px;">
            <input id="build-search" type="text" placeholder="Search (e.g., 'bed', 'wc', 'trackstopN')" />
          </div>
          <div id="build-groups"></div>
          <div class="tool custom" style="margin-top:8px;">
            <input type="text" placeholder="custom build token (e.g., Tl, wc, Cw, trackstopN{friction=500})" />
            <button data-apply-custom>Use</button>
          </div>
          <div class="note">Use exact tokens per DFHack build reference. Search filters the lists below.</div>
        </div>

        <div class="section" data-tools="place">
          <h3>Stockpiles (#place)</h3>
          <div class="tool-grid" id="place-stockpiles"></div>

          <div class="section" data-tools="place" style="margin-top:8px;">
            <h3>Multi-type stockpile</h3>
            <div id="place-multi-checks" class="tool-grid"></div>
            <div class="row" style="margin-top:8px;">
              <button id="place-multi-apply">Use selected types</button>
            </div>
            <div class="note">Build combined stockpiles like yr (corpses + refuse).</div>
          </div>

          <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
            <input id="place-name" type="text" placeholder="name (e.g. Seeds)" />
            <input id="place-take-from" type="text" placeholder="take_from (comma-separated stockpile names)" />
            <input id="place-give-to" type="text" placeholder="give_to (comma-separated stockpile names)" />
          </div>

          <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
            <input id="place-barrels" type="number" min="0" placeholder="barrels" />
            <input id="place-bins" type="number" min="0" placeholder="bins" />
            <input id="place-wheelbarrows" type="number" min="0" placeholder="wheelbarrows" />
            <input id="place-containers" type="number" min="0" placeholder="containers" />
          </div>

          <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap; align-items:center;">
            <label><input id="place-links-only" type="checkbox" /> links_only</label>
            <label><input id="place-quantum" type="checkbox" /> quantum</label>
            <label><input id="place-automelt" type="checkbox" /> automelt</label>
            <label><input id="place-autotrade" type="checkbox" /> autotrade</label>
            <label><input id="place-autodump" type="checkbox" /> autodump</label>
            <label><input id="place-autotrain" type="checkbox" /> autotrain</label>
          </div>

          <div class="row" style="margin-top:8px;">
            <input id="place-config" type="text" placeholder=":=configuration (e.g. seeds, booze)" />
          </div>

          <div class="row" style="margin-top:8px;">
            <input id="place-extent" type="text" placeholder="extent (e.g. 3x3 or (11x1))" />
          </div>

          <div class="row" style="margin-top:8px;">
            <input id="place-props" type="text" placeholder="extra props, e.g. desired_goblets=20 desired_soap=10" />
          </div>

          <div class="note">Structured fields build properties like {name=..., barrels=..., links_only=true}. Extra props are appended as-is. :=configuration is appended after properties.</div>
        </div>

        <div class="section" data-tools="zone">
          <h3>Zones</h3>
          <div class="tool-grid" id="zone-types"></div>
          <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
            <input id="zone-name" type="text" placeholder="name (e.g. Dining)" />
            <select id="zone-location">
              <option value="">location (none)</option>
              <option value="tavern">tavern</option>
              <option value="inn">inn</option>
              <option value="temple">temple</option>
              <option value="library">library</option>
              <option value="guildhall">guildhall</option>
              <option value="hospital">hospital</option>
            </select>
            <input id="zone-location-name" type="text" placeholder="location name (e.g. mainpub)" />
            <input id="zone-profession" type="text" placeholder="profession (for guildhall)" />
          </div>
          <div class="row" style="margin-top:8px;">
            <input id="zone-props" type="text" placeholder="extra props, e.g. desired_goblets=20 desired_suture=10" />
          </div>
          <div class="note">Structured fields build {name=..., location=tavern/mainpub}. Extra props appended as-is.</div>
        </div>

        <div class="section" data-tools="burrow">
          <h3>Burrows</h3>
          <div class="tool-grid" id="burrow-types"></div>
          <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
            <input id="burrow-name" type="text" placeholder="name (e.g. Safe)" />
            <label><input id="burrow-create" type="checkbox" /> create</label>
            <input id="burrow-civalert" type="text" placeholder="civalert (e.g. Siege)" />
          </div>
          <div class="row" style="margin-top:8px;">
            <input id="burrow-props" type="text" placeholder="extra props, e.g. autochop_wood=true" />
          </div>
          <div class="note">Structured fields build {name=..., create=true, civalert=...}. Extra props support autochop_* and others.</div>
        </div>

        <div class="section" data-tools="query">
          <h3>Query (q: settings)</h3>
          <div class="tool-grid">
            <div class="tool" data-tool="q:settings">Settings<small>q:settings</small></div>
            <div class="tool" data-tool="q:link">Link<small>q:link</small></div>
            <div class="tool" data-tool="q:profile">Profile<small>q:profile</small></div>
            <div class="tool" data-tool="">Eraser<small>blank</small></div>
            <div class="tool custom">
              <input type="text" placeholder="custom query token (e.g., q:take-from:SP name)" />
              <button data-apply-custom>Use</button>
            </div>
          </div>
          <div class="note hint">Query strings vary widely; use custom text to encode exact quickfort commands.</div>
        </div>
      </div>
    </aside>
    <section class="workspace">
      <div class="tabs" id="tabs"></div>
      <div class="gridwrap">
        <div id="grid-container" class="grid-container">
          <div class="axes-overlay" id="axes-overlay"></div>
          <table class="grid" id="grid"></table>
        </div>
      </div>
      <div class="statusbar">
        <div>
          <span>Active: <strong id="active-tab-label">dig</strong></span>
          <span> | Tool: <span class="kbd" id="active-tool">d</span></span>
          <span id="pos" class="note"></span>
        </div>
        <div class="actions">
          <button id="select-toggle" class="secondary" title="Toggle selection mode">Select Area</button>
          <button id="copy-selection" class="secondary" disabled>Copy Selection</button>
          <button id="cut-selection" class="secondary" disabled>Cut</button>
          <button id="paste-selection" class="secondary" disabled>Paste</button>
          <button id="clear-selection" class="secondary" disabled>Clear Selection</button>
          <span id="transform-controls" style="display:none; gap:6px; align-items:center;">
            <span class="sep" aria-hidden="true"></span>
            <button id="rotate-selection" class="secondary" title="Rotate 90° clockwise" disabled>Rotate</button>
            <button id="mirror-y-selection" class="secondary" title="Mirror Y (flip horizontally)" disabled>Mirror Y</button>
            <button id="mirror-x-selection" class="secondary" title="Mirror X (flip vertically)" disabled>Mirror X</button>
          </span>
          <label class="note" style="margin-left:8px; display:inline-flex; align-items:center; gap:6px;">
            <input id="paste-skip-blanks" type="checkbox" /> Skip blanks
          </label>
          <span class="sep" aria-hidden="true"></span>
          <button id="copycsv">Copy to clipboard</button>
          <button id="downloadcsv" class="primary">Download CSV</button>
          <button id="exportall" class="secondary">Export All</button>
          <button id="loadcsv" class="secondary">Load</button>
          <input id="fileinput" type="file" accept=".csv,.txt" style="display:none" />
        </div>
      </div>
    </section>
  </main>

  <script>
    // Blueprint tabs and their quickfort type headers
    const Tabs = [
      { id: 'dig', label: 'Dig', header: '#dig' },
      { id: 'build', label: 'Build', header: '#build' },
      { id: 'place', label: 'Stockpiles', header: '#place' },
      { id: 'zone', label: 'Zones', header: '#zone' },
      { id: 'burrow', label: 'Burrows', header: '#burrow' },
      { id: 'query', label: 'Query', header: '#query' },
    ];

    const defaultCols = 30;
    const defaultRows = 20;

const state = {
      cols: defaultCols,
      rows: defaultRows,
      activeTab: 'dig',
      activeZ: 0,       // active z-level index (0-based)
      zCount: 1,        // total number of z-levels
      // per-tab array of matrices, length == zCount
      grids: {},        // { [tabId]: Array<Matrix> }
      // tool selection scoped per tab
      selectedToolByTab: {},
      painting: false,
      lastPaintVal: '',
      zoom: 1,
      brushSize: 1,
  previewEnabled: true,
  // mirror axes
  mirrorVEnabled: false,
  mirrorHEnabled: false,
  mirrorVIndex: Math.floor(defaultCols/2), // vertical axis boundary index 0..cols
  mirrorHIndex: Math.floor(defaultRows/2), // horizontal axis boundary index 0..rows
  draggingAxis: null, // 'v' | 'h' | null
  // shape tools
      selectedShape: 'free',    // 'free' | 'rect' | 'line' | 'fill' | 'circle'
      shapeOutline: false,
      shapeStart: null,         // {r,c} during drag
      shaping: false,
      previewCells: new Set(),  // Set of "r,c" for shape preview
      // selection tool
      selectionMode: false,
      selecting: false,
      selStart: null,           // {r,c} during selection drag
      selectionRect: null,      // {r0,c0,r1,c1, tab, z}
      selectionCells: new Set(),
      // clipboard/paste
      copyBuffer: null,       // Array<Array<string>> or null
      pasteMode: false,
      pasteSkipBlanks: false,
      pasteHover: null,       // {r,c} for current hover when in paste mode
      pastePreviewCells: new Set(),
    };

    const gridEl = document.getElementById('grid');
    const gridWrapEl = document.querySelector('.gridwrap');
    const gridContainerEl = document.getElementById('grid-container');
    const axesOverlayEl = document.getElementById('axes-overlay');
    const tabsEl = document.getElementById('tabs');
    const activeTabLbl = document.getElementById('active-tab-label');
    const activeToolLbl = document.getElementById('active-tool');
    const posLbl = document.getElementById('pos');

    // init data structures
    function makeMatrix(rows, cols) {
      return Array.from({length: rows}, () => Array.from({length: cols}, () => ''));
    }

    function ensureGrids() {
      Tabs.forEach(t => {
        if (!state.grids[t.id]) state.grids[t.id] = [];
        // ensure one matrix per z-level
        while (state.grids[t.id].length < state.zCount) {
          state.grids[t.id].push(makeMatrix(state.rows, state.cols));
        }
        if (!state.selectedToolByTab[t.id]) state.selectedToolByTab[t.id] = '';
      });
      clampActiveZ();
    }

    function getMatrix(tabId = state.activeTab, z = state.activeZ) {
      ensureGrids();
      return state.grids[tabId][z];
    }

    function setMatrix(tabId, z, matrix) {
      ensureGrids();
      state.grids[tabId][z] = matrix;
    }

    function clampActiveZ() {
      if (state.zCount < 1) state.zCount = 1;
      if (state.activeZ < 0) state.activeZ = 0;
      if (state.activeZ >= state.zCount) state.activeZ = state.zCount - 1;
    }

    function clampSize() {
      const cols = Math.max(1, Math.min(300, parseInt(document.getElementById('cols').value || defaultCols, 10)));
      const rows = Math.max(1, Math.min(300, parseInt(document.getElementById('rows').value || defaultRows, 10)));
      state.cols = cols; state.rows = rows;
    }

    function resizeAllGrids(newRows, newCols) {
      Tabs.forEach(t => {
        const layers = state.grids[t.id] || [];
        for (let z = 0; z < layers.length; z++) {
          const old = layers[z];
          const next = makeMatrix(newRows, newCols);
          for (let r=0; r<Math.min(old.length, newRows); r++) {
            for (let c=0; c<Math.min(old[0].length, newCols); c++) next[r][c] = old[r][c];
          }
          layers[z] = next;
        }
        state.grids[t.id] = layers;
      });
    }

  function setGridSize(newRows, newCols) {
    const rows = Math.max(1, Math.min(300, parseInt(newRows, 10) || 1));
    const cols = Math.max(1, Math.min(300, parseInt(newCols, 10) || 1));
    if (rows === state.rows && cols === state.cols) return;
    state.rows = rows; state.cols = cols;
    clampAxes();
    const colsInput = document.getElementById('cols'); if (colsInput) colsInput.value = String(cols);
    const rowsInput = document.getElementById('rows'); if (rowsInput) rowsInput.value = String(rows);
    resizeAllGrids(rows, cols);
    renderGrid();
  }

    function renderTabs() {
      tabsEl.innerHTML = '';
      Tabs.forEach(t => {
        const b = document.createElement('button');
        b.textContent = t.label;
        b.className = t.id === state.activeTab ? 'active' : '';
        b.addEventListener('click', () => setActiveTab(t.id));
        tabsEl.appendChild(b);
      })
    }

    function setActiveTab(id) {
      state.activeTab = id;
      renderTabs();
      activeTabLbl.textContent = Tabs.find(t => t.id === id).label.toLowerCase();
      // show tools for active tab only
      document.querySelectorAll('aside .section').forEach(sec => {
        const scope = sec.getAttribute('data-tools');
        if (!scope) return;
        sec.classList.toggle('hidden', scope !== id);
      });
      // restore active tool label
      activeToolLbl.textContent = state.selectedToolByTab[id] || 'blank';
      renderGrid();
    }

    // Display-only token renderer for grid cells (keeps CSV/export unchanged)
    function displayTokenForGrid(raw, scopeId) {
      const s = String(raw || '');
      if (!s) return s;
      // For stockpiles/zones with properties, show base-only for compact display
      if (scopeId === 'place' || scopeId === 'zone') {
        const base = stripPropsAndCfg(s);
        if (base && base !== s) return base;
      }
      // Map track-like tokens to compact glyphs
      const base = stripPropsAndCfg(s);
      const m = /^(track)(ramp)?([NSEW]+)$/i.exec(base);
      if (!m) return s;
      const isRamp = !!m[2];
      // Canonicalize direction set
      const dirsSet = new Set(m[3].toUpperCase().split(''));
      const hasN = dirsSet.has('N');
      const hasS = dirsSet.has('S');
      const hasE = dirsSet.has('E');
      const hasW = dirsSet.has('W');
      // Single-direction
      if ((hasN?1:0)+(hasS?1:0)+(hasE?1:0)+(hasW?1:0) === 1) {
        if (hasN) return isRamp ? '▲' : '↑';
        if (hasS) return isRamp ? '▼' : '↓';
        if (hasE) return isRamp ? '▶' : '→';
        if (hasW) return isRamp ? '◀' : '←';
      }
      // Straight lines
      if (hasN && hasS && !hasE && !hasW) return isRamp ? '║' : '│';
      if (!hasN && !hasS && hasE && hasW) return isRamp ? '═' : '─';
      // Corners
      if (hasN && hasE && !hasS && !hasW) return isRamp ? '╚' : '└';
      if (hasN && hasW && !hasS && !hasE) return isRamp ? '╝' : '┘';
      if (hasS && hasE && !hasN && !hasW) return isRamp ? '╔' : '┌';
      if (hasS && hasW && !hasN && !hasE) return isRamp ? '╗' : '┐';
      // T junctions
      if (hasN && hasS && hasE && !hasW) return isRamp ? '╠' : '├'; // missing W
      if (hasN && hasS && hasW && !hasE) return isRamp ? '╣' : '┤'; // missing E
      if (hasN && hasE && hasW && !hasS) return isRamp ? '╩' : '┴'; // missing S
      if (hasS && hasE && hasW && !hasN) return isRamp ? '╦' : '┬'; // missing N
      // 4-way
      if (hasN && hasS && hasE && hasW) return isRamp ? '╬' : '┼';
      // Fallback to original
      return s;
    }

  function renderGrid() {
      const mat = getMatrix(state.activeTab, state.activeZ);
      gridEl.innerHTML = '';
      clearShapePreview();
      clearPastePreview();
      for (let r = 0; r < mat.length; r++) {
        const row = document.createElement('tr');
        for (let c = 0; c < mat[0].length; c++) {
          const td = document.createElement('td');
          td.dataset.r = r; td.dataset.c = c;
          const val = mat[r][c];
          // Display compact glyphs for tracks only; keep underlying token unchanged
          td.textContent = displayTokenForGrid(val, state.activeTab);
          styleCell(td, val, state.activeTab);
          // dig guidance overlay on non-dig tabs
          if (state.activeTab !== 'dig') maybeApplyDigOverlay(td, r, c);
          td.addEventListener('mousedown', (e) => onCellDown(e, r, c));
          td.addEventListener('mouseenter', (e) => onCellEnter(e, r, c));
          td.addEventListener('mousemove', () => posLbl.textContent = ` | R${r+1}C${c+1}`);
          td.addEventListener('contextmenu', (e) => { e.preventDefault(); /* right-click handled in onCellDown */ });
          row.appendChild(td);
        }
        gridEl.appendChild(row);
      }
      // After rendering the active grid, try to show a faded preview of the next grid (if space allows)
      maybeRenderPreview();
      renderAxesOverlay();
      // re-apply selection overlay after render
      applySelectionOverlayFromRect();
      // re-apply paste preview if we have a hover anchor
      applyPastePreviewFromHover();
  }

    // Zoom handling (shared across all tabs)
    const MIN_ZOOM = 0.5;
    const MAX_ZOOM = 3;
    const ZOOM_STEP = 0.1;
  function applyZoom() {
    const z = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom));
    state.zoom = z;
    document.documentElement.style.setProperty('--zoom', String(z));
    const lbl = document.getElementById('zoom-label');
    if (lbl) lbl.textContent = `${Math.round(z*100)}%`;
    // Re-evaluate preview visibility when zoom changes
    maybeRenderPreview();
    renderAxesOverlay();
  }
    function zoomIn() { state.zoom = +(state.zoom + ZOOM_STEP).toFixed(2); applyZoom(); }
    function zoomOut() { state.zoom = +(state.zoom - ZOOM_STEP).toFixed(2); applyZoom(); }
    function resetZoom() { state.zoom = 1; applyZoom(); }

    function onCellDown(e, r, c) {
      e.preventDefault();
      // Paste mode: paste buffer at clicked origin
      if (state.pasteMode && state.copyBuffer && e.button === 0) {
        pasteBufferAt(r, c);
        return;
      }
      if (state.pasteMode && e.button === 2) { // right-click cancels paste mode
        state.pasteMode = false;
        clearPastePreview();
        updateSelectionButtons();
        return;
      }
      // Selection mode: right-click exits selection mode entirely
      if (state.selectionMode && e.button === 2) {
        state.selectionMode = false;
        state.selecting = false;
        state.selStart = null;
        state.selectionRect = null;
        clearSelectionOverlay();
        updateSelectionButtons();
        return;
      }
      // Selection mode: start selecting rectangle, not painting
      if (state.selectionMode) {
        state.selecting = true;
        state.selStart = { r, c };
        setSelectionOverlay([[r,c]]);
        document.addEventListener('mouseup', onSelectMouseUpOnce, { once: true });
        return;
      }
      const shape = state.selectedShape || 'free';
      const tool = composeTokenForPaint(state.activeTab);
      const val = (e.button === 2) ? '' : tool; // right-click = erase
      state.lastPaintVal = val;

      if (shape === 'fill') {
        floodFill(r, c, val);
        return;
      }

      if (shape === 'free') {
        state.painting = true;
        applyBrushAt(r, c, val);
        document.addEventListener('mouseup', onMouseUpOnce, { once: true });
        return;
      }

      // start shape drag (rect, line, circle)
      state.shaping = true;
      state.shapeStart = { r, c };
      state.shapeLast = { r, c };
      // initial preview (single cell)
      setShapePreview([[r,c]]);
      document.addEventListener('mouseup', onMouseUpOnce, { once: true });
    }
    function onCellEnter(e, r, c) {
      // paste hover preview
      if (state.pasteMode && state.copyBuffer) {
        // Use the full-value/color paste preview, not just footprint
        state.pasteHover = { r, c };
        applyPastePreviewFromHover();
        return;
      }
      // freehand paint while dragging
      if (state.painting && state.selectedShape === 'free') {
        applyBrushAt(r, c, state.lastPaintVal);
        return;
      }
      // selection drag preview
      if (state.selectionMode && state.selecting && state.selStart) {
        const { r: r0, c: c0 } = state.selStart;
        const cells = rectCells(r0, c0, r, c, false, 1);
        setSelectionOverlay(cells);
        return;
      }
      // live shape preview
      if (state.shaping && state.shapeStart) {
        state.shapeLast = { r, c };
        const { r: r0, c: c0 } = state.shapeStart;
        const shape = state.selectedShape;
        let cells = [];
        if (shape === 'rect') {
          cells = rectCells(r0, c0, r, c, !!state.shapeOutline, getBrushSize());
        } else if (shape === 'line') {
          cells = lineCells(r0, c0, r, c, getBrushSize());
        } else if (shape === 'circle') {
          cells = circleCells(r0, c0, r, c, !!state.shapeOutline, getBrushSize());
        }
        setShapePreview(cells);
      }
    }
    function onMouseUpOnce() {
      const wasShaping = state.shaping && state.shapeStart;
      state.painting = false;
      if (!wasShaping) return;
      const { r: r0, c: c0 } = state.shapeStart;
      const { r: r1, c: c1 } = state.shapeLast || state.shapeStart;
      const shape = state.selectedShape;
      let cells = [];
      if (shape === 'rect') {
        cells = rectCells(r0, c0, r1, c1, !!state.shapeOutline, getBrushSize());
      } else if (shape === 'line') {
        cells = lineCells(r0, c0, r1, c1, getBrushSize());
      } else if (shape === 'circle') {
        cells = circleCells(r0, c0, r1, c1, !!state.shapeOutline, getBrushSize());
      }
      clearShapePreview();
      const val = state.lastPaintVal;
      for (const [rr,cc] of cells) applyTool(rr, cc, val);
      state.shaping = false;
      state.shapeStart = null;
      state.shapeLast = null;
    }

    function onSelectMouseUpOnce() {
      state.selecting = false;
      // finalize selection rect from current overlay
      const coords = Array.from(state.selectionCells).map(k => k.split(',').map(Number));
      if (!coords.length) { state.selectionRect = null; updateSelectionButtons(); return; }
      let r0 = Infinity, c0 = Infinity, r1 = -1, c1 = -1;
      for (const [r,c] of coords) { r0 = Math.min(r0,r); c0 = Math.min(c0,c); r1 = Math.max(r1,r); c1 = Math.max(c1,c); }
      state.selectionRect = { r0, c0, r1, c1, tab: state.activeTab, z: state.activeZ };
      updateSelectionButtons();
    }

    // ===== Selection overlay helpers =====
    function clearSelectionOverlay() {
      if (!state.selectionCells) state.selectionCells = new Set();
      state.selectionCells.forEach(k => {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (!td) return;
        td.classList.remove('selected');
      });
      state.selectionCells.clear();
    }
    function setSelectionOverlay(cells) {
      const next = new Set(cells.map(([r,c]) => rcKey(r,c)));
      state.selectionCells.forEach(k => { if (!next.has(k)) {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (td) td.classList.remove('selected');
      }});
      next.forEach(k => { if (!state.selectionCells.has(k)) {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (td) td.classList.add('selected');
      }});
      state.selectionCells = next;
    }
    function applySelectionOverlayFromRect() {
      clearSelectionOverlay();
      const rect = state.selectionRect;
      if (!rect) return;
      if (rect.tab !== state.activeTab || rect.z !== state.activeZ) return;
      const cells = rectCells(rect.r0, rect.c0, rect.r1, rect.c1, false, 1);
      setSelectionOverlay(cells);
    }
    function updateSelectionButtons() {
      const copyBtn = document.getElementById('copy-selection');
      const cutBtn = document.getElementById('cut-selection');
      const clearBtn = document.getElementById('clear-selection');
      const pasteBtn = document.getElementById('paste-selection');
      const rotateBtn = document.getElementById('rotate-selection');
      const mirrorXBtn = document.getElementById('mirror-x-selection');
      const mirrorYBtn = document.getElementById('mirror-y-selection');
      const transformWrap = document.getElementById('transform-controls');
      const skipCb = document.getElementById('paste-skip-blanks');
      const has = !!state.selectionRect;
      if (copyBtn) copyBtn.disabled = !has;
      if (cutBtn) cutBtn.disabled = !has;
      if (clearBtn) clearBtn.disabled = !has;
      if (pasteBtn) {
        pasteBtn.disabled = !state.copyBuffer;
        pasteBtn.classList.toggle('active', !!state.pasteMode);
      }
      if (skipCb) {
        skipCb.disabled = !state.copyBuffer;
        skipCb.checked = !!state.pasteSkipBlanks;
      }
      // Show transform controls only in paste mode with a buffer
      const showTransforms = (state.pasteMode && !!state.copyBuffer);
      if (transformWrap) transformWrap.style.display = showTransforms ? 'inline-flex' : 'none';
      const enableTransforms = showTransforms;
      if (rotateBtn) rotateBtn.disabled = !enableTransforms;
      if (mirrorXBtn) mirrorXBtn.disabled = !enableTransforms;
      if (mirrorYBtn) mirrorYBtn.disabled = !enableTransforms;
      const toggle = document.getElementById('select-toggle');
      if (toggle) toggle.classList.toggle('active', !!state.selectionMode);
      if (gridContainerEl) {
        gridContainerEl.classList.toggle('select-mode', !!state.selectionMode);
        gridContainerEl.classList.toggle('paste-mode', !!state.pasteMode);
      }
    }
    function clearSelection() {
      state.selectionRect = null;
      clearSelectionOverlay();
      updateSelectionButtons();
    }
    function copySelectedArea() {
      const rect = state.selectionRect;
      if (!rect) return;
      const mat = getMatrix(rect.tab, rect.z);
      const r0 = Math.max(0, Math.min(rect.r0, rect.r1));
      const r1 = Math.min(mat.length-1, Math.max(rect.r0, rect.r1));
      const c0 = Math.max(0, Math.min(rect.c0, rect.c1));
      const c1 = Math.min(mat[0].length-1, Math.max(rect.c0, rect.c1));
      const sub = [];
      for (let r=r0; r<=r1; r++) {
        const row = [];
        for (let c=c0; c<=c1; c++) row.push(mat[r][c] ?? '');
        sub.push(row);
      }
      const lines = matrixRowsToCSVLines(sub);
      copyToClipboard(lines.join('\n'));
      state.copyBuffer = sub;
      // remove active selection after copy and exit selection mode
      clearSelection();
      state.selectionMode = false;
      state.selecting = false;
      state.selStart = null;
      // enable paste button
      updateSelectionButtons();
    }

    // ===== Selection/paste transforms =====
    function rotateMatrixCW(mat) {
      const R = mat.length; if (!R) return [];
      const C = mat[0].length;
      const out = Array.from({length: C}, () => Array(R).fill(''));
      for (let r=0; r<R; r++) {
        for (let c=0; c<C; c++) {
          out[c][R-1-r] = mat[r][c];
        }
      }
      return out;
    }
    function mirrorMatrixX(mat) { // flip vertically (mirror across X axis)
      const R = mat.length; if (!R) return [];
      const C = mat[0].length;
      const out = Array.from({length:R}, (_, r) => Array(C).fill(''));
      for (let r=0; r<R; r++) {
        for (let c=0; c<C; c++) out[R-1-r][c] = mat[r][c];
      }
      return out;
    }
    function mirrorMatrixY(mat) { // flip horizontally (mirror across Y axis)
      const R = mat.length; if (!R) return [];
      const C = mat[0].length;
      const out = Array.from({length:R}, () => Array(C).fill(''));
      for (let r=0; r<R; r++) {
        for (let c=0; c<C; c++) out[r][C-1-c] = mat[r][c];
      }
      return out;
    }
    function transformSelectionOrBuffer(kind) {
      // Only active in paste mode; selection state is ignored.
      if (!(state.pasteMode && state.copyBuffer)) return;
      if (kind === 'rotate') state.copyBuffer = rotateMatrixCW(state.copyBuffer);
      else if (kind === 'mx') state.copyBuffer = mirrorMatrixX(state.copyBuffer);
      else if (kind === 'my') state.copyBuffer = mirrorMatrixY(state.copyBuffer);
      applyPastePreviewFromHover();
      updateSelectionButtons();
    }

    function cutSelectedArea() {
      const rect = state.selectionRect;
      if (!rect) return;
      const mat = getMatrix(rect.tab, rect.z);
      const r0 = Math.max(0, Math.min(rect.r0, rect.r1));
      const r1 = Math.min(mat.length-1, Math.max(rect.r0, rect.r1));
      const c0 = Math.max(0, Math.min(rect.c0, rect.c1));
      const c1 = Math.min(mat[0].length-1, Math.max(rect.c0, rect.c1));
      // build submatrix for clipboard
      const sub = [];
      for (let r=r0; r<=r1; r++) {
        const row = [];
        for (let c=c0; c<=c1; c++) row.push(mat[r][c] ?? '');
        sub.push(row);
      }
      const lines = matrixRowsToCSVLines(sub);
      copyToClipboard(lines.join('\n'));
      state.copyBuffer = sub;
      // clear the selected area
      for (let r=r0; r<=r1; r++) {
        for (let c=c0; c<=c1; c++) {
          mat[r][c] = '';
          // update DOM only if we are viewing the same tab/z
          if (state.activeTab === rect.tab && state.activeZ === rect.z) {
            const tr = gridEl.rows[r];
            if (tr) {
              const td = tr.cells[c];
              if (td) {
                td.textContent = '';
                styleCell(td, '', state.activeTab);
                if (state.activeTab !== 'dig') maybeApplyDigOverlay(td, r, c);
              }
            }
          }
        }
      }
      maybeRenderPreview();
      // clear selection overlay and exit modes
      clearSelection();
      state.selectionMode = false;
      state.selecting = false;
      state.selStart = null;
      updateSelectionButtons();
    }

    function pasteBufferAt(r, c) {
      if (!state.copyBuffer) return;
      const mat = getMatrix(state.activeTab, state.activeZ);
      const R = mat.length, C = mat[0].length;
      const h = state.copyBuffer.length;
      const w = state.copyBuffer[0]?.length || 0;
      for (let dr=0; dr<h; dr++) {
        for (let dc=0; dc<w; dc++) {
          const rr = r + dr, cc = c + dc;
          if (rr<0 || cc<0 || rr>=R || cc>=C) continue;
          const v = state.copyBuffer[dr][dc] ?? '';
          if (state.pasteSkipBlanks && (v === '' || v == null)) continue;
          // Direct set (no mirroring)
          mat[rr][cc] = v;
          const tr = gridEl.rows[rr];
          if (tr) {
            const td = tr.cells[cc];
            if (td) {
              td.textContent = displayTokenForGrid(v, state.activeTab);
              styleCell(td, v, state.activeTab);
              if (state.activeTab !== 'dig') maybeApplyDigOverlay(td, rr, cc);
            }
          }
        }
      }
      maybeRenderPreview();
      // keep paste mode active after placement; refresh preview at current hover
      applyPastePreviewFromHover();
      updateSelectionButtons();
    }

    function applyTool(r, c, val) {
      const mat = getMatrix(state.activeTab, state.activeZ);
      const R = mat.length, C = mat[0].length;
      function inBounds(rr, cc) { return rr>=0 && cc>=0 && rr<R && cc<C; }
      function setCell(rr, cc, v) {
        if (!inBounds(rr, cc)) return;
        mat[rr][cc] = v;
        const tr = gridEl.rows[rr];
        if (tr) {
          const td = tr.cells[cc];
          if (td) {
            td.textContent = displayTokenForGrid(v, state.activeTab);
            styleCell(td, v, state.activeTab);
            if (state.activeTab !== 'dig') maybeApplyDigOverlay(td, rr, cc);
          }
        }
      }
      // original
      const coords = new Set();
      const key = (rr,cc)=> rr+","+cc;
      if (inBounds(r,c)) coords.add(key(r,c));
      // mirror across vertical/horizontal axes (support half-cell positions)
      const alpha = Number(state.mirrorVIndex) || 0;
      const beta = Number(state.mirrorHIndex) || 0;
      if (state.mirrorVEnabled) {
        const c2 = Math.round(2*alpha - 1 - c);
        if (inBounds(r, c2)) coords.add(key(r, c2));
      }
      if (state.mirrorHEnabled) {
        const r2 = Math.round(2*beta - 1 - r);
        if (inBounds(r2, c)) coords.add(key(r2, c));
        if (state.mirrorVEnabled) {
          const c2 = Math.round(2*alpha - 1 - c);
          const r2b = Math.round(2*beta - 1 - r);
          if (inBounds(r2b, c2)) coords.add(key(r2b, c2));
        }
      }
      // apply
      coords.forEach(k=>{
        const [rr,cc] = k.split(',').map(Number);
        setCell(rr, cc, val);
      });
      // Refresh previews so they reflect changes (esp. dig overlay)
      maybeRenderPreview();
    }

    function getBrushSize() {
      const input = document.getElementById('brush-size');
      const raw = parseInt(input?.value || state.brushSize || 1, 10);
      return Math.max(1, Math.min(25, isNaN(raw) ? 1 : raw));
    }

    function applyBrushAt(r, c, val) {
      const size = getBrushSize();
      if (size <= 1) { applyTool(r, c, val); return; }
      const half = Math.floor((size - 1) / 2);
      const r0 = r - half;
      const c0 = c - half;
      const r1 = r0 + size - 1;
      const c1 = c0 + size - 1;
      for (let rr = r0; rr <= r1; rr++) {
        for (let cc = c0; cc <= c1; cc++) {
          applyTool(rr, cc, val);
        }
      }
    }

    // ===== Shape tools helpers =====
    function rcKey(r,c){ return r+","+c; }
    function clearShapePreview() {
      // remove preview class from previously marked cells
      if (!state.previewCells) state.previewCells = new Set();
      state.previewCells.forEach(k => {
        const [rStr,cStr] = k.split(',');
        const r = +rStr, c = +cStr;
        const tr = gridEl.rows[r]; if (!tr) return;
        const td = tr.cells[c]; if (!td) return;
        td.classList.remove('shape-preview');
      });
      state.previewCells.clear();
    }
    function setShapePreview(cells) {
      // cells: Array of [r,c]
      const next = new Set(cells.map(([r,c]) => rcKey(r,c)));
      // remove those not in next
      state.previewCells.forEach(k => { if (!next.has(k)) {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (td) td.classList.remove('shape-preview');
      }});
      // add new ones
      next.forEach(k => { if (!state.previewCells.has(k)) {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (td) td.classList.add('shape-preview');
      }});
      state.previewCells = next;
    }
    // Paste hover preview helpers
    function clearPastePreview() {
      if (!state.pastePreviewCells) state.pastePreviewCells = new Set();
      state.pastePreviewCells.forEach(k => {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (!td) return;
        td.classList.remove('paste-preview');
        const ghost = td.querySelector('.paste-ghost'); if (ghost) ghost.remove();
      });
      state.pastePreviewCells.clear();
    }
    function setPastePreview(cells) {
      // cells can be [[r,c]] or [[r,c,color,val]]
      const next = new Set(cells.map(([r,c]) => rcKey(r,c)));
      state.pastePreviewCells.forEach(k => { if (!next.has(k)) {
        const [rStr,cStr] = k.split(',');
        const tr = gridEl.rows[+rStr]; if (!tr) return;
        const td = tr.cells[+cStr]; if (td) {
          td.classList.remove('paste-preview');
          const ghost = td.querySelector('.paste-ghost'); if (ghost) ghost.remove();
        }
      }});
      cells.forEach(item => {
        const r = item[0], c = item[1];
        const k = rcKey(r,c);
        const tr = gridEl.rows[r]; if (!tr) return;
        const td = tr.cells[c]; if (!td) return;
        td.classList.add('paste-preview');
        // Build or update ghost element
        let ghost = td.querySelector('.paste-ghost');
        if (!ghost) { ghost = document.createElement('div'); ghost.className = 'paste-ghost'; td.appendChild(ghost); }
        const bgHex = item[2] || '#666666';
        const val = item[3] ?? '';
        ghost.style.background = bgHex;
        ghost.textContent = displayTokenForGrid(val, state.activeTab);
        // choose readable text color based on bg
        const lum = luminanceOfHex(bgHex);
        ghost.style.color = lum > 0.6 ? '#111' : '#fff';
        state.pastePreviewCells.add(k);
      });
      state.pastePreviewCells = next;
    }
    function pasteFootprintCells(r, c) {
      const mat = getMatrix(state.activeTab, state.activeZ);
      const R = mat.length, C = mat[0].length;
      const h = state.copyBuffer?.length || 0;
      const w = state.copyBuffer?.[0]?.length || 0;
      const cells = [];
      for (let dr=0; dr<h; dr++) {
        for (let dc=0; dc<w; dc++) {
          const rr = r + dr, cc = c + dc;
          if (rr<0 || cc<0 || rr>=R || cc>=C) continue;
          cells.push([rr, cc]);
        }
      }
      return cells;
    }
    function rgbaFromHex(hex, alpha) {
      const {r,g,b} = hexToRgb(hex);
      return `rgba(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)},${alpha})`;
    }
    function baseColorForToken(scopeId, token) {
      const s = String(token || '');
      if (!s) return null;
      if (scopeId === 'dig') return getDigColorForToken(s);
      if (scopeId === 'place') return getPlaceColorForToken(s);
      if (scopeId === 'zone') return getZoneColorForToken(s);
      if (scopeId === 'burrow') return getBurrowColorForToken(s) || '#577590';
      if (scopeId === 'build') {
        const base = stripPropsAndCfg(s);
        return getBuildColorForToken(base);
      }
      if (scopeId === 'query') return '#ff9500';
      return null;
    }
    function applyPastePreviewFromHover() {
      if (!state.pasteMode || !state.copyBuffer || !state.pasteHover) return;
      const { r, c } = state.pasteHover;
      clearPastePreview();
      const h = state.copyBuffer.length;
      const w = state.copyBuffer[0]?.length || 0;
      const triples = [];
      for (let dr=0; dr<h; dr++) {
        for (let dc=0; dc<w; dc++) {
          const rr = r + dr, cc = c + dc;
          const mat = getMatrix(state.activeTab, state.activeZ);
          if (rr<0 || cc<0 || rr>=mat.length || cc>=mat[0].length) continue;
          const v = state.copyBuffer[dr][dc] ?? '';
          // Always skip blank tokens in preview; show only copied tiles
          if (!String(v)) continue;
          const baseHex = baseColorForToken(state.activeTab, v) || '#666666';
          triples.push([rr, cc, baseHex, v]);
        }
      }
      setPastePreview(triples);
    }
    function clampToGrid(r,c){
      const mat = getMatrix(state.activeTab, state.activeZ);
      if (r < 0 || c < 0 || r >= mat.length || c >= mat[0].length) return null;
      return [r,c];
    }
    function rectCells(r0,c0,r1,c1, outline, thickness) {
      const mat = getMatrix(state.activeTab, state.activeZ);
      const R = mat.length, C = mat[0].length;
      const rr0 = Math.max(0, Math.min(r0, r1));
      const rr1 = Math.min(R-1, Math.max(r0, r1));
      const cc0 = Math.max(0, Math.min(c0, c1));
      const cc1 = Math.min(C-1, Math.max(c0, c1));
      const cells = [];
      if (!outline) {
        for (let r=rr0; r<=rr1; r++) for (let c=cc0; c<=cc1; c++) cells.push([r,c]);
        return cells;
      }
      const t = Math.max(1, thickness|0);
      for (let r=rr0; r<=rr1; r++) {
        for (let c=cc0; c<=cc1; c++) {
          const onTop = r - rr0 < t;
          const onBottom = rr1 - r < t;
          const onLeft = c - cc0 < t;
          const onRight = cc1 - c < t;
          if (onTop || onBottom || onLeft || onRight) cells.push([r,c]);
        }
      }
      return cells;
    }
    function bresenhamLine(r0,c0,r1,c1) {
      const pts = [];
      const dx = Math.abs(c1 - c0), sx = c0 < c1 ? 1 : -1;
      const dy = -Math.abs(r1 - r0), sy = r0 < r1 ? 1 : -1;
      let err = dx + dy;
      let r = r0, c = c0;
      while (true) {
        pts.push([r,c]);
        if (r === r1 && c === c1) break;
        const e2 = 2 * err;
        if (e2 >= dy) { err += dy; c += sx; }
        if (e2 <= dx) { err += dx; r += sy; }
      }
      return pts;
    }
    function lineCells(r0,c0,r1,c1, thickness) {
      const mat = getMatrix(state.activeTab, state.activeZ);
      const R = mat.length, C = mat[0].length;
      const pts = bresenhamLine(r0,c0,r1,c1);
      const t = Math.max(1, thickness|0);
      const half = Math.floor((t-1)/2);
      const out = new Set();
      for (const [r,c] of pts) {
        for (let dr=-half; dr<=half; dr++) {
          for (let dc=-half; dc<=half; dc++) {
            const rr = r+dr, cc = c+dc;
            if (rr>=0 && cc>=0 && rr<R && cc<C) out.add(rcKey(rr,cc));
          }
        }
      }
      return Array.from(out, k => k.split(',').map(Number));
    }
    function circleCells(r0, c0, r1, c1, outline, thickness) {
      const mat = getMatrix(state.activeTab, state.activeZ);
      const R = mat.length, C = mat[0].length;
      const dr = r1 - r0, dc = c1 - c0;
      let rad = Math.round(Math.hypot(dr, dc));
      if (rad < 0) rad = 0;
      const cells = [];
      if (rad === 0) {
        if (r0>=0 && c0>=0 && r0<R && c0<C) cells.push([r0,c0]);
        return cells;
      }
      const t = Math.max(1, thickness|0);
      // distance threshold band/fill
      const rOuter = rad + (outline ? Math.floor((t-1)/2) : 0);
      const rInner = outline ? Math.max(0, rad - Math.ceil((t-1)/2)) : 0;
      const outer2 = rOuter*rOuter;
      const inner2 = rInner*rInner;
      const rmin = Math.max(0, r0 - rOuter), rmax = Math.min(R-1, r0 + rOuter);
      const cmin = Math.max(0, c0 - rOuter), cmax = Math.min(C-1, c0 + rOuter);
      for (let r=rmin; r<=rmax; r++) {
        for (let c=cmin; c<=cmax; c++) {
          const rr = r - r0, cc = c - c0;
          const d2 = rr*rr + cc*cc;
          if (!outline) {
            if (d2 <= outer2) cells.push([r,c]);
          } else {
            if (d2 <= outer2 && d2 >= inner2) cells.push([r,c]);
          }
        }
      }
      return cells;
    }
    function floodFill(r,c, val) {
      const mat = getMatrix(state.activeTab, state.activeZ);
      if (r<0 || c<0 || r>=mat.length || c>=mat[0].length) return;
      const target = mat[r][c];
      if (target === val) return;
      const R = mat.length, C = mat[0].length;
      const q = [[r,c]];
      const seen = new Set([rcKey(r,c)]);
      let steps = 0, cap = 50000;
      while (q.length) {
        const [rr,cc] = q.shift();
        applyTool(rr, cc, val);
        steps++; if (steps > cap) break;
        const nb = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dr,dc] of nb) {
          const r2 = rr+dr, c2 = cc+dc;
          if (r2<0||c2<0||r2>=R||c2>=C) continue;
          const k = rcKey(r2,c2);
          if (seen.has(k)) continue;
          if (mat[r2][c2] === target) { seen.add(k); q.push([r2,c2]); }
        }
      }
    }

    // Tool selection handling (scoped to active tab only)
    function wireTools() {
      document.querySelectorAll('aside .section').forEach(section => {
        const scope = section.getAttribute('data-tools');
        if (!scope) return;
        // tool buttons
        section.querySelectorAll('.tool').forEach(el => {
          const custom = el.classList.contains('custom');
          if (custom) {
            const input = el.querySelector('input');
            const btn = el.querySelector('button[data-apply-custom]');
            btn.addEventListener('click', () => {
              const val = (input.value || '').trim();
              if (!val) return;
              if (scope !== state.activeTab) return; // only apply to active grid
              state.selectedToolByTab[scope] = val;
              updateToolUI();
            });
          } else {
            // Only interactive if it represents a real tool button
            if (!el.hasAttribute('data-tool')) return;
            el.addEventListener('click', () => {
              if (scope !== state.activeTab) return; // tool applies only to its grid
              const val = el.getAttribute('data-tool') || '';
              state.selectedToolByTab[scope] = val;
              updateToolUI();
            });
          }
        });
      });
    }

    function updateToolUI() {
      // update label (include markers/properties preview)
      const preview = composeTokenForPaint(state.activeTab) || 'blank';
      activeToolLbl.textContent = preview;
      // update active class only inside visible tool section
      document.querySelectorAll('aside .section').forEach(section => {
        const scope = section.getAttribute('data-tools');
        if (!scope) return;
        const current = state.selectedToolByTab[scope] || '';
        section.querySelectorAll('.tool').forEach(btn => {
          if (btn.classList.contains('custom')) { btn.classList.remove('active'); return; }
          if (!btn.hasAttribute('data-tool')) { btn.classList.remove('active'); return; }
          const val = btn.getAttribute('data-tool') || '';
          btn.classList.toggle('active', current === val && scope === state.activeTab);
        });
      });
    }

    // Export helpers
    function matrixToCSV(mat, header) {
      const rows = mat.map(row => row.map(cell => {
        const s = String(cell ?? '');
        if (s.includes(',') || s.includes('"') || s.includes('\n')) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }).join(','));
      rows.unshift(header);
      return rows.join('\n');
    }

    function download(filename, text) {
      const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    function copyToClipboard(text) {
      navigator.clipboard?.writeText(text).catch(()=>{});
    }

    // Build CSV lines for a matrix (no header)
    function matrixRowsToCSVLines(mat) {
      return mat.map(row => row.map(cell => {
        const s = String(cell ?? '');
        if (s.includes(',') || s.includes('"') || s.includes('\n')) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }).join(','));
    }

    // Multi-z CSV for a single tab, using #> between floors
    function tabToMultiZCSV(tabId) {
      ensureGrids();
      const tab = Tabs.find(t => t.id === tabId) || Tabs[0];
      const lines = [tab.header];
      for (let z = 0; z < state.zCount; z++) {
        if (z > 0) lines.push('#>');
        const mat = getMatrix(tabId, z);
        const rows = matrixRowsToCSVLines(mat);
        for (const r of rows) lines.push(r);
      }
      return lines.join('\n');
    }

    // --- Z-level UI helpers ---
    function updateZLabel() {
      const lbl = document.getElementById('z-label');
      if (lbl) lbl.textContent = `Z${state.activeZ+1}/${state.zCount}`;
    }

    // --- Next-grid preview rendering ---
    const PREVIEW_SCALE = 0.80; // previews at a static 80% of main
    const PREVIEW_GAP = 16; // px, should match .gridwrap gap

    function getFollowingTabIds(id) {
      const i = Tabs.findIndex(t => t.id === id);
      if (i < 0) return [];
      return Tabs.slice(i+1).map(t => t.id);
    }
    function getNextTabId(id) {
      const i = Tabs.findIndex(t => t.id === id);
      if (i < 0) return null;
      const nxt = Tabs[i+1];
      return nxt ? nxt.id : null;
    }

    function removeExistingPreview() {
      if (!gridWrapEl) return;
      gridWrapEl.querySelectorAll('.preview').forEach(el => el.remove());
    }

    function buildPreviewTable(scopeId, zIndex = state.activeZ) {
      const mat = getMatrix(scopeId, zIndex);
      if (!mat) return null;
      const tbl = document.createElement('table');
      tbl.className = 'grid';
      for (let r = 0; r < mat.length; r++) {
        const tr = document.createElement('tr');
        for (let c = 0; c < mat[0].length; c++) {
          const td = document.createElement('td');
          const val = mat[r][c];
          // Use same display mapping in previews
          td.textContent = displayTokenForGrid(val, scopeId);
          styleCell(td, val, scopeId);
          if (scopeId !== 'dig') maybeApplyDigOverlay(td, r, c);
          tr.appendChild(td);
        }
        tbl.appendChild(tr);
      }
      return tbl;
    }

    function maybeRenderPreview() {
      if (!gridWrapEl) return;
      removeExistingPreview();
      if (!state.previewEnabled) return;
      const nextId = getNextTabId(state.activeTab);
      if (!nextId) return; // last grid, nothing to preview
      const mainWidth = gridEl?.offsetWidth || 0;
      const previewWidth = Math.round(mainWidth * PREVIEW_SCALE);
      
      // East (right) preview
      const wrapEast = document.createElement('div');
      wrapEast.className = 'preview';
      wrapEast.style.width = previewWidth + 'px';
      wrapEast.style.flex = `0 0 ${previewWidth}px`;
      const tblEast = buildPreviewTable(nextId);
      if (tblEast) {
        wrapEast.appendChild(tblEast);
        gridWrapEl.appendChild(wrapEast);
      }
      
      // South (below) preview: only if Z > 1, show same tab at Z-1
      if (state.activeZ > 0) {
        const wrapSouth = document.createElement('div');
        wrapSouth.className = 'preview south';
        const tblSouth = buildPreviewTable(state.activeTab, state.activeZ - 1);
        if (tblSouth) {
          wrapSouth.appendChild(tblSouth);
          gridWrapEl.appendChild(wrapSouth);
        }
      }
    }

    // Dig overlay helper
    function maybeApplyDigOverlay(td, r, c) {
      // Remove any existing overlay
      const prev = td.querySelector('.dig-overlay');
      if (prev) prev.remove();
      const digMat = getMatrix('dig', state.activeZ);
      const dv = (digMat?.[r]?.[c]) || '';
      if (!dv) return;
      const ov = document.createElement('div');
      ov.className = 'dig-overlay';
      td.appendChild(ov);
    }

    // ===== Mirror Axes (UI + logic) =====
    function clampAxes() {
      state.mirrorVIndex = Math.max(0, Math.min(state.cols, Number(state.mirrorVIndex)||0));
      state.mirrorHIndex = Math.max(0, Math.min(state.rows, Number(state.mirrorHIndex)||0));
    }
    function getCellMetrics() {
      const r0 = gridEl.rows[0];
      const td0 = r0 && r0.cells[0];
      const cellW = td0 ? td0.offsetWidth : 0;
      const cellH = td0 ? td0.offsetHeight : 0;
      return { cellW, cellH };
    }
    function vAxisLeftPx(a) {
      const rows = gridEl.rows;
      if (!rows || !rows[0]) return 0;
      if (a <= 0) return 0;
      if (a >= state.cols) return gridEl.offsetWidth;
      const k = Math.floor(a);
      const cell = rows[0].cells[k];
      if (!cell) return 0;
      const next = rows[0].cells[k+1];
      const start = cell.offsetLeft;
      const end = next ? next.offsetLeft : (start + cell.offsetWidth);
      const t = a - k; // 0..1, 0=left border, 0.5=center, 1=right border
      return start + (end - start) * t;
    }
    function hAxisTopPx(a) {
      if (!gridEl || gridEl.rows.length === 0) return 0;
      if (a <= 0) return 0;
      if (a >= state.rows) return gridEl.offsetHeight;
      const k = Math.floor(a);
      const row = gridEl.rows[k];
      if (!row) return 0;
      const nextRow = gridEl.rows[k+1];
      const start = row.offsetTop;
      const cell = row.cells[0];
      const rowHeight = cell ? cell.offsetHeight : (nextRow ? (nextRow.offsetTop - start) : 0);
      const end = nextRow ? nextRow.offsetTop : (start + rowHeight);
      const t = a - k;
      return start + (end - start) * t;
    }
    function startDragAxis(kind, e) {
      e.preventDefault(); e.stopPropagation();
      state.draggingAxis = kind; // 'v' or 'h'
      const onMove = (ev) => {
        const rect = gridEl.getBoundingClientRect();
        const { cellW, cellH } = getCellMetrics();
        if (state.draggingAxis === 'v' && cellW > 0) {
          let x = ev.clientX - rect.left;
          x = Math.max(0, Math.min(x, rect.width));
          // snap to half-cell increments
          const idx = Math.round(x / (cellW/2)) / 2;
          state.mirrorVIndex = Math.max(0, Math.min(state.cols, idx));
        } else if (state.draggingAxis === 'h' && cellH > 0) {
          let y = ev.clientY - rect.top;
          y = Math.max(0, Math.min(y, rect.height));
          const idx = Math.round(y / (cellH/2)) / 2;
          state.mirrorHIndex = Math.max(0, Math.min(state.rows, idx));
        }
        renderAxesOverlay();
      };
      const onUp = () => {
        state.draggingAxis = null;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      };
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp, { once: true });
    }
    function renderAxesOverlay() {
      if (!axesOverlayEl || !gridEl) return;
      clampAxes();
      // size overlay to grid
      axesOverlayEl.style.width = gridEl.offsetWidth + 'px';
      axesOverlayEl.style.height = gridEl.offsetHeight + 'px';
      axesOverlayEl.innerHTML = '';
      if (!state.mirrorVEnabled && !state.mirrorHEnabled) return;
      // vertical axis
      if (state.mirrorVEnabled) {
        const left = vAxisLeftPx(state.mirrorVIndex);
        const handle = document.createElement('div');
        handle.className = 'axis-handle v';
        handle.style.left = left + 'px';
        const grip = document.createElement('div'); grip.className = 'grip';
        handle.appendChild(grip);
        handle.addEventListener('mousedown', (e) => startDragAxis('v', e));
        axesOverlayEl.appendChild(handle);
      }
      // horizontal axis
      if (state.mirrorHEnabled) {
        const top = hAxisTopPx(state.mirrorHIndex);
        const handle = document.createElement('div');
        handle.className = 'axis-handle h';
        handle.style.top = top + 'px';
        const grip = document.createElement('div'); grip.className = 'grip';
        handle.appendChild(grip);
        handle.addEventListener('mousedown', (e) => startDragAxis('h', e));
        axesOverlayEl.appendChild(handle);
      }
    }

    // Color coding
    const COLOR_DIG = {
      d:'#3fa7ff', h:'#70d6ff', u:'#ffd166', j:'#ffd166', i:'#fca311', r:'#90be6d', z:'#ff6b6b', n:'#8d99ae', M:'#9b5de5', v:'#577590', T:'#43aa8b', t:'#40916c', p:'#70e000', s:'#adb5bd', e:'#6c757d', F:'#4cc9f0', x:'#2b2d42'
    };
    const COLOR_PLACE = { // stockpile types
      a:'#8dd3c7', f:'#ffffb3', u:'#bebada', n:'#fb8072', y:'#80b1d3', r:'#fdb462', s:'#b3de69', w:'#fccde5', e:'#d9d9d9', b:'#bc80bd', h:'#ccebc5', l:'#ffed6f', z:'#1f78b4', S:'#6a3d9a', g:'#b15928', p:'#e31a1c', d:'#33a02c', c:'#ff7f00'
    };
    const COLOR_ZONE = {
      m:'#8ecae6', b:'#219ebc', h:'#ffb703', n:'#fb8500', p:'#f94144', w:'#577590', j:'#90be6d', f:'#f3722c', s:'#f9c74f', o:'#43aa8b', D:'#4d908e', B:'#577590', a:'#277da1', d:'#f8961e', t:'#2a9d8f', T:'#9c6644', g:'#6a994e', c:'#b56576'
    };
    const COLOR_BUILD_GROUP = {
      'Furniture':'#5e60ce',
      'Roads & Plots':'#6c757d',
      'Workshops':'#00b4d8',
      'Furnaces':'#ffafcc',
      'Siege Engines':'#ff8fab',
      'Constructions':'#8d99ae',
      'Track Stops':'#90be6d',
      'Traps & Levers':'#f77f00',
      'Constructed Tracks':'#43aa8b',
      'Mechanical Power':'#4cc9f0'
    };
    let BUILD_TOKEN_GROUP = null; // token -> group name
    function ensureBuildTokenGroup() {
      if (BUILD_TOKEN_GROUP) return;
      BUILD_TOKEN_GROUP = {};
      try {
        (BUILD_GROUPS||[]).forEach(group => {
          (group.items||[]).forEach(([v]) => { BUILD_TOKEN_GROUP[v] = group.name; });
        });
      } catch (_) { BUILD_TOKEN_GROUP = {}; }
    }

    // Individual colors for Furniture tokens
    const FURNITURE_COLOR_PALETTE = [
      '#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6','#06b6d4','#0ea5e9',
      '#3b82f6','#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#fb7185','#fda4af','#fdba74',
      '#fde047','#bef264','#86efac','#5eead4','#67e8f9','#93c5fd','#a5b4fc','#c4b5fd'
    ];
    let FURNITURE_TOKEN_COLOR = null; // token -> hex color
    function ensureFurnitureTokenColors() {
      if (FURNITURE_TOKEN_COLOR) return;
      FURNITURE_TOKEN_COLOR = {};
      try {
        const furn = (BUILD_GROUPS||[]).find(g => g.name === 'Furniture');
        if (furn && Array.isArray(furn.items)) {
          let idx = 0;
          furn.items.forEach(([v]) => {
            const base = stripPropsAndCfg(v);
            if (!base) return;
            if (FURNITURE_TOKEN_COLOR[base]) return; // keep first assignment
            const color = FURNITURE_COLOR_PALETTE[idx % FURNITURE_COLOR_PALETTE.length];
            FURNITURE_TOKEN_COLOR[base] = color; idx++;
          });
        }
      } catch (_) { FURNITURE_TOKEN_COLOR = {}; }
    }

    function getBuildGroupForToken(base) {
      ensureBuildTokenGroup();
      if (!base) return null;
      let group = BUILD_TOKEN_GROUP[base];
      if (!group) {
        if (/^trackstop/i.test(base)) group = 'Track Stops';
        else if (/^track|^trackramp/i.test(base)) group = 'Constructed Tracks';
        else if (/^roller/i.test(base) || /^M/.test(base)) group = 'Mechanical Power';
        else if (/^(ew|es|el|eg|ea|ek|en)$/.test(base)) group = 'Furnaces';
        else if (/^(C[wWdfru dxFSDg]|ga|gd|gx|gw)$/.test(base)) group = 'Constructions';
        else if (/^T[swtpcS]$/.test(base) || base === 'Tl') group = 'Traps & Levers';
        else if (/^[a-zA-Z]{1,2}$/.test(base)) group = 'Furniture';
        else group = 'Workshops';
      }
      return group || null;
    }

    function getBuildColorForToken(base) {
      const group = getBuildGroupForToken(base);
      if (!group) return null;
      if (group === 'Furniture') {
        ensureFurnitureTokenColors();
        const col = FURNITURE_TOKEN_COLOR[base];
        if (col) return col;
      }
      return COLOR_BUILD_GROUP[group] || '#7b2cbf';
    }

    function stripPropsAndCfg(token) {
      if (!token) return '';
      let s = String(token);
      s = s.replace(/\{[^}]*\}/g, ''); // remove {...}
      s = s.replace(/:=.*$/, ''); // remove :=config
      // remove trailing extent like (3x3)
      s = s.replace(/\(\s*\d+\s*x\s*\d+\s*\)\s*$/, '');
      return s;
    }

    function stripDigMarkersAndPriority(token) {
      let s = stripPropsAndCfg(token);
      s = s.replace(/^(mb|mw|md)+/, '');
      s = s.replace(/[1-7]$/, '');
      return s;
    }

    function getDigColorForToken(token) {
      const base = stripDigMarkersAndPriority(token||'');
      const key = base.charAt(0);
      return COLOR_DIG[key] || null;
    }

    function getPlaceColorForToken(token) {
      const base = stripPropsAndCfg(token||'');
      const key = base.charAt(0);
      return COLOR_PLACE[key] || null;
    }

    function getZoneColorForToken(token) {
      const base = stripPropsAndCfg(token||'');
      const key = base.charAt(0);
      return COLOR_ZONE[key] || null;
    }

    function getBurrowColorForToken(token) {
      const base = stripPropsAndCfg(token||'');
      const key = base.charAt(0);
      if (key === 'a') return '#2b9348';
      if (key === 'e') return '#d90429';
      return null;
    }

    function ensureReadableText(td, bg) {
      // Simple luminance check to pick text color
      const hex = bg.replace('#','');
      if (hex.length === 6) {
        const r = parseInt(hex.substring(0,2),16)/255;
        const g = parseInt(hex.substring(2,4),16)/255;
        const b = parseInt(hex.substring(4,6),16)/255;
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        td.style.color = lum > 0.6 ? '#111' : '#fff';
      } else {
        td.style.color = 'var(--fg)';
      }
    }

    function gradientForLetters(letters, map) {
      const cols = letters.map(ch => map[ch] || '#444');
      if (!cols.length) return null;
      if (cols.length === 1) return cols[0];
      const n = cols.length;
      const stops = [];
      for (let i=0;i<n;i++) {
        const start = Math.round((i/n)*100);
        const end = Math.round(((i+1)/n)*100);
        stops.push(`${cols[i]} ${start}% ${end}%`);
      }
      return `linear-gradient(90deg, ${stops.join(', ')})`;
    }

    // --- Unique text color helper (display-only) ---
    function hashHue(str) {
      let h = 0;
      for (let i=0;i<str.length;i++) h = (h * 31 + str.charCodeAt(i)) % 360;
      return h;
    }
    function hslToHex(h, s, l) {
      s /= 100; l /= 100;
      const k = n => (n + h/30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      const r = Math.round(255 * f(0));
      const g = Math.round(255 * f(8));
      const b = Math.round(255 * f(4));
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }
    function hexToRgb(hex) {
      const m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(hex||'');
      if (!m) return {r:68,g:68,b:68};
      return { r: parseInt(m[1],16)/255, g: parseInt(m[2],16)/255, b: parseInt(m[3],16)/255 };
    }
    function luminanceOfHex(hex) {
      const {r,g,b} = hexToRgb(hex);
      return 0.2126*r + 0.7152*g + 0.0722*b;
    }
    function uniqueTextColorForKey(key, bgHex) {
      const hue = hashHue(key);
      const bgLum = luminanceOfHex(bgHex || '#444');
      // pick lightness based on background brightness for contrast
      const light = bgLum < 0.5 ? 70 : 30;
      return hslToHex(hue, 70, light);
    }

    function isPlaceholderToken(raw) {
      const t = String(raw||'').trim();
      if (!t) return true; // empty
      const base = stripPropsAndCfg(t);
      return base === '' || base === '#' || base === '#>';
    }

    function styleCell(td, val, scopeId) {
      // reset
      td.style.background = 'var(--cell)';
      td.style.color = 'var(--fg)';
      td.classList.remove('mini-token');
      const s = String(val||'');
      if (!s) return;
      if (isPlaceholderToken(s)) return; // keep dark styling for placeholders
      if (scopeId === 'dig') {
        const base = stripDigMarkersAndPriority(s);
        const key = base.charAt(0);
        const col = COLOR_DIG[key];
        if (col) { td.style.background = col; ensureReadableText(td, col); }
        return;
      }
      if (scopeId === 'place') {
        const base = stripPropsAndCfg(s);
        const hasProps = base !== s;
        // multi-type combo: use gradient
        const letters = base.split('');
        const grad = gradientForLetters(letters, COLOR_PLACE);
        if (grad) {
          td.style.background = grad;
          // pick text color based on first color
          const first = COLOR_PLACE[letters[0]] || '#444';
          if (hasProps) {
            td.classList.add('mini-token');
            td.style.color = uniqueTextColorForKey(s, first);
          } else {
            ensureReadableText(td, first);
          }
        } else {
          // single-type with no mapping; fallback color handling
          const first = COLOR_PLACE[letters[0]] || '#444';
          td.style.background = first;
          if (hasProps) {
            td.classList.add('mini-token');
            td.style.color = uniqueTextColorForKey(s, first);
          } else {
            ensureReadableText(td, first);
          }
        }
        return;
      }
      if (scopeId === 'zone') {
        const base = stripPropsAndCfg(s);
        const hasProps = base !== s;
        const key = base.charAt(0);
        const col = COLOR_ZONE[key];
        if (col) {
          td.style.background = col;
          if (hasProps) {
            td.classList.add('mini-token');
            td.style.color = uniqueTextColorForKey(s, col);
          } else {
            ensureReadableText(td, col);
          }
        }
        return;
      }
      if (scopeId === 'burrow') {
        const base = stripPropsAndCfg(s);
        const key = base.charAt(0);
        const col = key === 'a' ? '#2b9348' : key === 'e' ? '#d90429' : '#577590';
        td.style.background = col; ensureReadableText(td, col);
        return;
      }
      if (scopeId === 'build') {
        const base = stripPropsAndCfg(s);
        const col = getBuildColorForToken(base);
        if (!col) return;
        td.style.background = col; ensureReadableText(td, col); return;
      }
      if (scopeId === 'query') {
        td.style.background = '#ff9500'; td.style.color = '#111';
        return;
      }
    }

    // CSV import helpers
    function parseCSV(text) {
      const norm = (text||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
      const rows = [];
      let field = '';
      let inQuotes = false;
      let row = [];
      for (let i = 0; i <= norm.length; i++) {
        const ch = norm[i];
        if (inQuotes) {
          if (ch === '"') {
            const next = norm[i+1];
            if (next === '"') { field += '"'; i++; }
            else { inQuotes = false; }
          } else if (ch === undefined) {
            // end of input while in quotes: finalize
            row.push(field); rows.push(row); break;
          } else {
            field += ch;
          }
        } else {
          if (ch === '"') { inQuotes = true; }
          else if (ch === ',') { row.push(field); field = ''; }
          else if (ch === '\n' || ch === undefined) {
            row.push(field); field = '';
            rows.push(row); row = [];
            if (ch === undefined) break;
          } else {
            field += ch;
          }
        }
      }
      // normalize to rectangular matrix by padding with ''
      const maxCols = rows.reduce((m, r) => Math.max(m, r.length), 0);
      return rows.map(r => r.length < maxCols ? r.concat(Array(maxCols - r.length).fill('')) : r);
    }

    function firstCSVCell(line) {
      let i = 0, cell = '', inQuotes = false;
      while (i < line.length) {
        const ch = line[i];
        if (inQuotes) {
          if (ch === '"') {
            const next = line[i+1];
            if (next === '"') { cell += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          cell += ch; i++; continue;
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') break;
          cell += ch; i++;
        }
      }
      return cell.trim();
    }

    function detectHeaderLine(line) {
      const first = firstCSVCell(line || '');
      const m = /^#(dig|build|place|zone|burrow|query)\b/i.exec(first);
      return m ? `#${m[1].toLowerCase()}` : null;
    }

    function splitSheetsFromText(text) {
      const norm = (text||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
      const lines = norm.split('\n');
      const sheets = [];
      let i = 0;
      while (i < lines.length) {
        while (i < lines.length && lines[i].trim() === '') i++;
        if (i >= lines.length) break;
        const header = detectHeaderLine(lines[i]);
        if (header) {
          i++;
          const buf = [];
          while (i < lines.length && !detectHeaderLine(lines[i])) { buf.push(lines[i]); i++; }
          while (buf.length && buf[buf.length-1].trim() === '') buf.pop();
          const mat = parseCSV(buf.join('\n'));
          sheets.push({ header, matrix: mat });
        } else {
          // single sheet without recognizable header: parse the rest into current tab
          const buf = lines.slice(i).join('\n');
          const mat = parseCSV(buf);
          sheets.push({ header: null, matrix: mat });
          break;
        }
      }
      return sheets;
    }

    function headerToTabId(header) {
      if (!header) return state.activeTab;
      const mode = /^#(dig|build|place|zone|burrow|query)\b/i.exec(header)?.[1]?.toLowerCase();
      const t = Tabs.find(t => t.id === mode);
      return t ? t.id : state.activeTab;
    }

    // Wire header controls
    // Live resize on input/change
    const colsInputEl = document.getElementById('cols');
    const rowsInputEl = document.getElementById('rows');
    if (colsInputEl) {
      colsInputEl.addEventListener('change', () => setGridSize(state.rows, colsInputEl.value));
      colsInputEl.addEventListener('input', () => {
        const v = parseInt(colsInputEl.value, 10);
        if (!isNaN(v)) setGridSize(state.rows, v);
      });
    }
    if (rowsInputEl) {
      rowsInputEl.addEventListener('change', () => setGridSize(rowsInputEl.value, state.cols));
      rowsInputEl.addEventListener('input', () => {
        const v = parseInt(rowsInputEl.value, 10);
        if (!isNaN(v)) setGridSize(v, state.cols);
      });
    }
    // Increment/decrement buttons
    const colsInc = document.getElementById('cols-inc');
    const colsDec = document.getElementById('cols-dec');
    const rowsInc = document.getElementById('rows-inc');
    const rowsDec = document.getElementById('rows-dec');
    colsInc?.addEventListener('click', () => setGridSize(state.rows, state.cols + 1));
    colsDec?.addEventListener('click', () => setGridSize(state.rows, state.cols - 1));
    rowsInc?.addEventListener('click', () => setGridSize(state.rows + 1, state.cols));
    rowsDec?.addEventListener('click', () => setGridSize(state.rows - 1, state.cols));
    document.getElementById('cleargrid').addEventListener('click', () => {
      const mat = makeMatrix(state.rows, state.cols);
      setMatrix(state.activeTab, state.activeZ, mat);
      renderGrid();
    });
    // Zoom buttons
    document.getElementById('zoom-in').addEventListener('click', () => { zoomIn(); });
    document.getElementById('zoom-out').addEventListener('click', () => { zoomOut(); });
    // Keyboard shortcuts for zoom
    document.addEventListener('keydown', (e) => {
      if (!e.ctrlKey && !e.metaKey) return;
      if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomIn(); }
      else if (e.key === '-' || e.key === '_') { e.preventDefault(); zoomOut(); }
      else if (e.key === '0') { e.preventDefault(); resetZoom(); }
    });

    // Z-level controls
    const zUpBtn = document.getElementById('z-up');
    const zDownBtn = document.getElementById('z-down');
    const zAddBtn = document.getElementById('z-add');
    const zDelBtn = document.getElementById('z-del');
    zUpBtn?.addEventListener('click', () => {
      clampActiveZ();
      if (state.activeZ < state.zCount - 1) state.activeZ++;
      updateZLabel();
      renderGrid();
    });
    zDownBtn?.addEventListener('click', () => {
      clampActiveZ();
      if (state.activeZ > 0) state.activeZ--;
      updateZLabel();
      renderGrid();
    });
    zAddBtn?.addEventListener('click', () => {
      // add a new empty layer for each tab
      Tabs.forEach(t => {
        if (!state.grids[t.id]) state.grids[t.id] = [];
        state.grids[t.id].push(makeMatrix(state.rows, state.cols));
      });
      state.zCount += 1;
      state.activeZ = state.zCount - 1;
      updateZLabel();
      renderGrid();
    });
    zDelBtn?.addEventListener('click', () => {
      if (state.zCount <= 1) return; // keep at least one level
      Tabs.forEach(t => {
        if (!state.grids[t.id]) state.grids[t.id] = [];
        if (state.grids[t.id].length > 1) {
          state.grids[t.id].splice(state.activeZ, 1);
        }
      });
      state.zCount = Math.max(1, state.zCount - 1);
      clampActiveZ();
      updateZLabel();
      renderGrid();
    });

    // Selection controls wiring
    const selectToggle = document.getElementById('select-toggle');
    if (selectToggle) {
      selectToggle.addEventListener('click', () => {
        state.selectionMode = !state.selectionMode;
        if (state.selectionMode) {
          // entering selection mode cancels painting/shaping preview
          state.painting = false;
          state.shaping = false;
          clearShapePreview();
          // disable paste mode while selecting
          state.pasteMode = false;
          clearPastePreview();
        }
        updateSelectionButtons();
      });
    }
    const copySelBtn = document.getElementById('copy-selection');
    copySelBtn?.addEventListener('click', () => copySelectedArea());
    const cutSelBtn = document.getElementById('cut-selection');
    cutSelBtn?.addEventListener('click', () => cutSelectedArea());
    const clearSelBtn = document.getElementById('clear-selection');
    clearSelBtn?.addEventListener('click', () => clearSelection());
    const pasteSelBtn = document.getElementById('paste-selection');
    pasteSelBtn?.addEventListener('click', () => {
      if (!state.copyBuffer) return;
      state.pasteMode = !state.pasteMode;
      if (state.pasteMode) {
        state.selectionMode = false;
      } else { clearPastePreview(); }
      updateSelectionButtons();
    });
    const pasteSkipCb = document.getElementById('paste-skip-blanks');
    pasteSkipCb?.addEventListener('change', () => {
      state.pasteSkipBlanks = !!pasteSkipCb.checked;
      if (state.pasteMode) applyPastePreviewFromHover();
    });
    // Transform controls
    const rotBtn = document.getElementById('rotate-selection');
    const mxBtn = document.getElementById('mirror-x-selection');
    const myBtn = document.getElementById('mirror-y-selection');
    rotBtn?.addEventListener('click', () => transformSelectionOrBuffer('rotate'));
    mxBtn?.addEventListener('click', () => transformSelectionOrBuffer('mx'));
    myBtn?.addEventListener('click', () => transformSelectionOrBuffer('my'));
    // Keyboard shortcuts: Esc clears selection, Ctrl/Cmd+C copies selection if present
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (state.pasteMode) { state.pasteMode = false; clearPastePreview(); updateSelectionButtons(); return; }
        clearSelection();
        return;
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C')) {
        if (state.selectionRect) { e.preventDefault(); copySelectedArea(); }
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'x' || e.key === 'X')) {
        if (state.selectionRect) { e.preventDefault(); cutSelectedArea(); }
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'v' || e.key === 'V')) {
        if (state.copyBuffer) {
          e.preventDefault();
          state.pasteMode = !state.pasteMode;
          if (!state.pasteMode) clearPastePreview(); else state.selectionMode = false;
          updateSelectionButtons();
        }
      }
    });

    // (Header project save/load removed to match the copy file.)

    // Wire statusbar actions
    document.getElementById('copycsv').addEventListener('click', () => {
      const csv = tabToMultiZCSV(state.activeTab);
      copyToClipboard(csv);
    });
    document.getElementById('downloadcsv').addEventListener('click', () => {
      const csv = tabToMultiZCSV(state.activeTab);
      download(`${state.activeTab}.csv`, csv);
    });
    document.getElementById('exportall').addEventListener('click', () => {
      // Concatenate all tabs; each tab emits multi-z CSV
      let bundle = '';
      Tabs.forEach((t, idx) => {
        const csv = tabToMultiZCSV(t.id);
        if (idx) bundle += '\n\n';
        bundle += csv;
      });
      download('quickfort-blueprints.csv', bundle);
    });

    // Load CSV(s) into grids
    document.getElementById('loadcsv').addEventListener('click', () => {
      document.getElementById('fileinput').click();
    });
    document.getElementById('fileinput').addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const text = String(reader.result||'');
          const sheets = splitSheetsFromText(text);
          if (!sheets.length) return;
          // compute max dimensions (ignore control rows like #> / #<)
          let maxR = 0, maxC = 0;
          sheets.forEach(s => {
            const filtered = s.matrix.filter(r => !/^#([<>])(\d+)?$/.test(String(r?.[0] ?? '').trim()));
            const rows = filtered.length;
            const cols = filtered.reduce((m,r)=>Math.max(m, r.length), 0);
            if (rows > maxR) maxR = rows;
            if (cols > maxC) maxC = cols;
          });
          maxR = Math.max(1, maxR);
          maxC = Math.max(1, maxC);
          if (maxR !== state.rows || maxC !== state.cols) {
            state.rows = maxR; state.cols = maxC;
            const colsInput = document.getElementById('cols'); if (colsInput) colsInput.value = String(maxC);
            const rowsInput = document.getElementById('rows'); if (rowsInput) rowsInput.value = String(maxR);
            resizeAllGrids(state.rows, state.cols);
          }
          // import each sheet, supporting multi-z via #> / #< control rows
          let firstTab = null;
          sheets.forEach(s => {
            const id = headerToTabId(s.header);
            if (!firstTab) firstTab = id;
            importSectionToMultiZ(id, s.matrix);
          });
          if (firstTab) setActiveTab(firstTab);
          else renderGrid();
        } catch (err) {
          console.error('Failed to load CSV:', err);
        } finally {
          e.target.value = '';
        }
      };
      reader.readAsText(f);
    });

    // Import a single sheet (matrix rows) into multi-z layers using #> / #< rows
    function importSectionToMultiZ(tabId, rows) {
      let currentZ = 0;
      const matrices = [makeMatrix(state.rows, state.cols)];
      function ensureLocalZ(idx) {
        while (matrices.length <= idx) matrices.push(makeMatrix(state.rows, state.cols));
      }
      let rr = 0;
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i] || [];
        const first = String(row[0] ?? '').trim();
        const m = first.match(/^#([<>])(\d+)?$/);
        if (m) {
          const dir = m[1];
          const step = m[2] ? parseInt(m[2], 10) : 1;
          if (dir === '>') currentZ += step; else if (dir === '<') currentZ = Math.max(0, currentZ - step);
          ensureLocalZ(currentZ);
          rr = 0;
          continue;
        }
        ensureLocalZ(currentZ);
        const mat = matrices[currentZ];
        if (rr >= state.rows) continue;
        for (let c = 0; c < Math.min(row.length, state.cols); c++) {
          mat[rr][c] = row[c] ?? '';
        }
        rr++;
      }
      // extend global zCount if needed and ensure global structures
      if (matrices.length > state.zCount) state.zCount = matrices.length;
      ensureGrids();
      resizeAllGrids(state.rows, state.cols);
      // copy into global state for this tab
      for (let z = 0; z < matrices.length; z++) {
        setMatrix(tabId, z, matrices[z]);
      }
      clampActiveZ();
      updateZLabel();
    }

    // Help popover wiring
    (function wireHelpPopover(){
      const btn = document.getElementById('help-btn');
      const pop = document.getElementById('help-pop');
      if (!btn || !pop) return;
      const hide = () => { pop.classList.add('hidden'); };
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        pop.classList.toggle('hidden');
      });
      document.addEventListener('click', (e) => {
        const t = e.target;
        if (t === btn || pop.contains(t)) return;
        hide();
      });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hide(); });
    })();

    // Init
    // Token catalogs from DFHack quickfort guide
    const DIG_BASIC = [
      ['d','Dig'], ['h','Channel'], ['u','Up stair'], ['j','Down stair'], ['i','Up/Down stair'], ['r','Ramp'], ['z','Remove up stairs/ramps'],
      ['n','Remove construction'], ['M','Toggle marker/blueprint'], ['v','Toggle engraving visibility'], ['T','Carve track (generic)'],
      ['t','Chop trees'], ['p','Gather plants'], ['s','Smooth'], ['e','Engrave'], ['F','Fortification'], ['x','Remove designation'], ['','Eraser']
    ];
    const DIG_FLAGS = [
      ['bc','Claim items'], ['bf','Forbid items'], ['bm','Melt items'], ['bM','Unmelt items'], ['bd','Dump items'], ['bD','Undump items'], ['bh','Hide items'], ['bH','Unhide items'], ['oh','High traffic'], ['on','Normal traffic'], ['ol','Low traffic'], ['or','Restricted traffic']
    ];
    const DIG_TRACKS = [
      'trackN','trackS','trackE','trackW','trackNS','trackEW','trackNE','trackNW','trackSE','trackSW','trackNSE','trackNSW','trackNEW','trackSEW','trackNSEW'
    ];

    const PLACE_STOCKPILES = [
      ['','Eraser'],
      ['a','animal'], ['f','food'], ['u','furniture'], ['n','coins'], ['y','corpses'], ['r','refuse'], ['s','stone'], ['w','wood'], ['e','gem'], ['b','barsblocks'], ['h','cloth'], ['l','leather'], ['z','ammo'], ['S','sheets'], ['g','finished goods'], ['p','weapons'], ['d','armor'], ['c','custom']
    ];

    const ZONE_TYPES = [
      ['','Eraser'],
